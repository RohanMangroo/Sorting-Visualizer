{"version":3,"sources":["store/buttonSelectionReducer.js","store/barsReducer.js","Algorithms/bubbleSort.js","Algorithms/selectionSort.js","Algorithms/insertionSort.js","Algorithms/quickSort.js","Algorithms/mergeSort.js","Algorithms/heapSort.js","utils.js","Components/Controls.js","Components/Bars.js","store/metricsReducer.js","Components/StartButton.js","Components/Metrics.js","descriptions.js","Components/AlgoDescription.js","Components/SortingPage.js","Components/Nav.js","App.js","store/rootReducer.js","index.js"],"names":["UPDATE_ALGO_BUTTON_SELECTION","UPDATE_MAIN_BUTTON","initialState","algoName","mainButton","buttonSelectionReducer","state","type","payload","button","name","UPDATE_BARS","UPDATE_BAR_COUNT","UPDATE_SPEED","updateBarCount","barCount","nums","displayBars","initialHeights","speed","barsReducer","bars","updates","a","updateSwaps_","updateChecks_","updateMainButton_","array","swaps","checks","Array","from","stopPos","length","i","j","colorBars","colors","red","swapNums","orange","swapBarHeights","green","sorted","currentSmallest","metricsInfo","splits","quickSortHelper","start","stop","updateRecursiveSplits_","pivot","left","right","arr","heights","auxArr","slice","auxHeights","mergeHelper","st","sp","mn","ax","hts","axHts","metInfo","dP","spd","mP","Math","floor","merge","displaySort","k","constructHeap","swap","siftDown","firstParentIndex","pos","lastIndex","leftChild","rightChild","indexToSwap","positionOne","positionTwo","startSelectedAlgo","buttonSelection","bubbleSort","selectionSort","insertionSort","quickSort","mergeSort","heapSort","barOnePos","barTwoPos","heightOne","style","height","heightTwo","pause","Promise","resolve","setTimeout","arrayOfPos","color","backgroundColor","posOne","posTwo","blue","getClassName","selectedButton","buttonName","connect","dispatch","updateAlgoButtonSelection_","updateAlgoButtonSelection","updateBarCount_","value","updateSpeed_","className","onClick","e","target","handleButtonClick","disabled","min","max","step","onChange","handleBarSlider","defaultValue","handleSpeed","updateBars_","updateBars","barsContainer","useRef","useEffect","containerHeight","current","clientHeight","childNodes","heightPercentages","randomNum","random","heightPercentage","push","genArray","ref","map","uuidv4","UPDATE_SWAPS","UPDATE_CHECKS","UPDATE_RECURSIVE_SPLITS","RESET_METRICS","updateMainButton","updateSwaps","updateChecks","updateRecursiveSplits","resetMetrics_","btnName","btnType","toLowerCase","window","location","reload","handleClick","metrics","descriptions","title","algoDescript","vizDescript","learningMode","complexity","useState","descript","setDescript","getSelectedDescription","SortingPage","Nav","App","rootReducer","combineReducers","metricsReducer","store","createStore","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.7e166f17.chunk.js","sourcesContent":["// Type constants\nconst UPDATE_ALGO_BUTTON_SELECTION = 'UPDATE_ALGO_BUTTON_SELECTION';\nconst UPDATE_MAIN_BUTTON = 'UPDATE_MAIN_BUTTON';\n\n// Action creators\nexport const updateAlgoButtonSelection = (button) => {\n  return {\n    type: UPDATE_ALGO_BUTTON_SELECTION,\n    payload: {\n      button,\n    },\n  };\n};\n\nexport const updateMainButton = (name) => {\n  return {\n    type: UPDATE_MAIN_BUTTON,\n    payload: {\n      name,\n    },\n  };\n};\n\nconst initialState = {\n  algoName: 'bubbleSort',\n  mainButton: 'START',\n};\n\nconst buttonSelectionReducer = (state = initialState, { type, payload }) => {\n  switch (type) {\n    case UPDATE_ALGO_BUTTON_SELECTION:\n      return {\n        ...state,\n        algoName: payload.button,\n      };\n    case UPDATE_MAIN_BUTTON:\n      return {\n        ...state,\n        mainButton: payload.name,\n      };\n    default:\n      return state;\n  }\n};\n\nexport default buttonSelectionReducer;\n","// Action Type\nconst UPDATE_BARS = 'UPDATE_BARS';\nconst UPDATE_BAR_COUNT = 'UPDATE_BAR_COUNT';\nconst UPDATE_SPEED = 'UPDATE_SPEED';\n\n// Action creators\nexport const updateBars = (nums, displayBars, initialHeights) => {\n  return {\n    type: UPDATE_BARS,\n    payload: {\n      nums,\n      displayBars,\n      initialHeights,\n    },\n  };\n};\n//This Redux function is used by the sliders to update the barCount. The barCount prop is attached to the Bars component, so if ever barCount is updated, the Bars component wil re render\nexport const updateBarCount = (barCount) => {\n  return {\n    type: UPDATE_BAR_COUNT,\n    payload: {\n      barCount,\n    },\n  };\n};\n\nexport const updateSpeed = (speed) => {\n  return {\n    type: UPDATE_SPEED,\n    payload: {\n      speed,\n    },\n  };\n};\n\nconst initialState = {\n  nums: [],\n  displayBars: [],\n  initialHeights: [],\n  barCount: 100,\n  speed: 100,\n};\n\nconst barsReducer = (state = initialState, { type, payload }) => {\n  switch (type) {\n    case UPDATE_BARS:\n      return {\n        ...state,\n        nums: payload.nums,\n        displayBars: payload.displayBars,\n        initialHeights: payload.initialHeights,\n      };\n    case UPDATE_BAR_COUNT:\n      return {\n        ...state,\n        barCount: payload.barCount,\n      };\n    case UPDATE_SPEED:\n      return {\n        ...state,\n        speed: payload.speed,\n      };\n    default:\n      return state;\n  }\n};\n\nexport default barsReducer;\n","import { colorBars, swapNums, swapBarHeights, colors } from '../utils';\n\n/**====================================================================================================================================\n * The array of numbers being sorted and the array of bars on the screen are NOT one in the same, but they do have a connection\n * When the array of numbers is generated, an array of heights is also generated\n * The array of heights is based off of the random numbers AND the current height of the container\n * This way we can assign the height of the bar as a percentage, so now the bar height will always be responsive to the container height\n * So no matter the current heights of the bars on the screen they always maintain their relationship to the numbers that generated them\n=======================================================================================================================================*/\n\nexport default async function bubbleSort(bars, updates) {\n  //Destructuring the redux states\n  const { updateSwaps_, updateChecks_, updateMainButton_ } = updates;\n  let { nums: array, displayBars, speed } = bars;\n\n  //Local swaps and checks\n  let swaps = 0;\n  let checks = 0;\n\n  //The bars grabbed from the DOM are 'array-like' and not an actual array so we need to convert it to an array by calling Array.from\n  displayBars = Array.from(displayBars);\n\n  //A stop position used in bubbleSort to prevent the algorithm from scanning already sorted items\n  let stopPos = array.length - 1;\n\n  for (let i = 0; i < array.length; i++) {\n    for (let j = 0; j < stopPos; j++) {\n      //Coloring the current bar\n      await colorBars([j], colors.red, displayBars, speed);\n      //Adding to the checks count\n      updateChecks_(++checks);\n      if (array[j] > array[j + 1]) {\n        //Adding to the swaps count\n        updateSwaps_(++swaps);\n        //Here we are swapping the numbers in the array, this is a seperate array than the bars on the screen\n        swapNums(j, j + 1, array);\n        //If the bars are out of order, they need to be swapped so we color both red\n        await colorBars([j, j + 1], colors.orange, displayBars, speed);\n        //The swapping of heights on the screen\n        swapBarHeights(j, j + 1, displayBars);\n      } else {\n        //If they are in order, no need to swap them so we color both green\n        await colorBars([j, j + 1], colors.green, displayBars, speed * 4);\n      }\n      //After we process the first position we need to put it's color back to white to simulate movement\n      colorBars([j], 'white', displayBars);\n    }\n    //Once we reach the end we'll color the bar sorted\n    colorBars([stopPos], colors.sorted, displayBars);\n    stopPos -= 1;\n  }\n\n  updateMainButton_('NEW');\n}\n","import { colorBars, swapNums, swapBarHeights, colors } from '../utils';\n\n/**====================================================================================================================================\n * The array of numbers being sorted and the array of bars on the screen are NOT one in the same, but they do have a connection\n * When the array of numbers is generated, an array of heights is also generated\n * The array of heights is based off of the random numbers AND the current height of the container\n * This way we can assign the height of the bar as a percentage, so now the bar height will always be responsive to the container height\n * So no matter the current heights of the bars on the screen they always maintain their relationship to the numbers that generated them\n=======================================================================================================================================*/\n\nexport default async function selectionSort(bars, updates) {\n  //Destructuring the redux states\n  const { updateSwaps_, updateChecks_, updateMainButton_ } = updates;\n  let { nums: array, displayBars, speed } = bars;\n\n  //Local swaps and checks\n  let swaps = 0;\n  let checks = 0;\n\n  //The bars grabbed from the DOM are 'array-like' and not an actual array so we need to convert it to an array by calling Array.from\n  displayBars = Array.from(displayBars);\n\n  for (let i = 0; i < array.length; i++) {\n    let currentSmallest = i;\n\n    for (let j = i + 1; j < array.length; j++) {\n      //We will color the currentSmallest bar red\n      colorBars([currentSmallest], colors.red, displayBars);\n      //The bar who's position we are holding we color green\n      colorBars([i], colors.green, displayBars);\n      //Adding to the checks count\n      updateChecks_(++checks);\n      //The scanning bars we color orange\n      await colorBars([j], colors.orange, displayBars, speed);\n\n      if (array[j] <= array[currentSmallest]) {\n        //If the bar that we are at is less than the current smallest bar we swap their colors\n        colorBars([j], colors.red, displayBars);\n        //We uncolor the previous smallest\n        colorBars([currentSmallest], 'white', displayBars);\n        //We then update currenSmallest to be the new smallest bar\n        currentSmallest = j;\n      } else {\n        //Otherwise, after we have processed the current bar we turn it back to white to simulate movement\n        colorBars([j], 'white', displayBars);\n      }\n    }\n    //Once we have gone through a pass of the inner for loop and we have found a currentSmallest now we will swap it with the position we are holding in the outter loop\n    swapNums(i, currentSmallest, array);\n    //swap the bar heights\n    swapBarHeights(i, currentSmallest, displayBars);\n    //update swap count\n    updateSwaps_(++swaps);\n    //We set both the i position and the currentSmallest position back to white\n    colorBars([i, currentSmallest], 'white', displayBars);\n    //We update the sorted bar to be colored\n    colorBars([i], colors.sorted, displayBars);\n  }\n\n  updateMainButton_('NEW');\n}\n","import { colorBars, swapNums, swapBarHeights, colors } from '../utils';\n\n/**====================================================================================================================================\n * The array of numbers being sorted and the array of bars on the screen are NOT one in the same, but they do have a connection\n * When the array of numbers is generated, an array of heights is also generated\n * The array of heights is based off of the random numbers AND the current height of the container\n * This way we can assign the height of the bar as a percentage, so now the bar height will always be responsive to the container height\n * So no matter the current heights of the bars on the screen they always maintain their relationship to the numbers that generated them\n=======================================================================================================================================*/\n\nexport default async function insertionSort(bars, updates) {\n  //Destructuring the redux states\n  const { updateSwaps_, updateChecks_, updateMainButton_ } = updates;\n  let { nums: array, displayBars, speed } = bars;\n\n  //Local checks and swaps\n  let checks = 0;\n  let swaps = 0;\n\n  //The bars grabbed from the DOM are 'array-like' and not an actual array so we need to convert it to an array by calling Array.from\n  displayBars = Array.from(displayBars);\n\n  for (let i = 1; i < array.length; i++) {\n    let j = i;\n    //Adding to the checks count\n    updateChecks_(++checks);\n    //Coloring the initial sorted partition of the array, which begins at the oth index\n    colorBars([j - 1], colors.sorted, displayBars, speed);\n    //This while loop will place the current element in it's sorted place\n    while (array[j] < array[j - 1] && j > 0) {\n      //If position 'j' needs to move to the front, color it red\n      await colorBars([j], colors.red, displayBars, speed);\n      //Here we are swapping the numbers in the array, this is a seperate array than the bars on the screen\n      swapNums(j, j - 1, array);\n      //The swapping of heights on the screen\n      swapBarHeights(j, j - 1, displayBars);\n      //Once we swap positions position 'j', which is sorted needs to be colored sorted\n      colorBars([j], colors.sorted, displayBars);\n      //position j will move one step to the left and on the next iteration of the while loop will be colored red\n      j--;\n      //Adding to the swaps count\n      updateSwaps_(++swaps);\n    }\n    //If position 'j' has found it's place, color it green\n    await colorBars([j], colors.green, displayBars, speed * 6);\n    //Then color it sorted\n    colorBars([j], colors.sorted, displayBars, speed);\n  }\n\n  updateMainButton_('NEW');\n}\n","import { colorBars, swapNums, swapBarHeights, colors } from '../utils';\n\n/**====================================================================================================================================\n * The array of numbers being sorted and the array of bars on the screen are NOT one in the same, but they do have a connection\n * When the array of numbers is generated, an array of heights is also generated\n * The array of heights is based off of the random numbers AND the current height of the container\n * This way we can assign the height of the bar as a percentage, so now the bar height will always be responsive to the container height\n * So no matter the current heights of the bars on the screen they always maintain their relationship to the numbers that generated them\n=======================================================================================================================================*/\n\n/*============\nMain Function\n==============*/\nexport default async function quickSort(bars, updates) {\n  //The bars grabbed from the DOM are 'array-like' and not an actual array so we need to convert it to an array by calling Array.from()\n  bars.displayBars = Array.from(bars.displayBars);\n\n  //Here we are creating an object that holds all the metric info that we will pass down\n  const metricsInfo = { swaps: 0, checks: 0, splits: 0, updates };\n\n  //Helper method that will do the work\n  await quickSortHelper(0, bars.nums.length - 1, bars, metricsInfo);\n\n  updates.updateMainButton_('NEW');\n}\n\n/*============\nHelper Function\n==============*/\nasync function quickSortHelper(start, stop, bars, metricsInfo) {\n  //Destructuring the attributes\n  const { updateSwaps_, updateChecks_, updateRecursiveSplits_ } =\n    metricsInfo.updates;\n\n  //Here i'm renaming 'nums' to be array\n  const { nums: array, speed, displayBars } = bars;\n\n  //============================================================//\n\n  if (start >= stop) {\n    if (start < array.length) {\n      colorBars([start], colors.sorted, displayBars);\n    }\n    return array;\n  }\n  //Establishing our positions\n  let pivot = start;\n  //Here we will color the current pivot green\n  colorBars([pivot], colors.green, displayBars);\n  let left = start + 1;\n  let right = stop;\n\n  while (left <= right) {\n    //Our compared bars(left and right) will be colored red\n    await colorBars([left, right], colors.red, displayBars, speed);\n\n    if (array[left] > array[pivot] && array[right] < array[pivot]) {\n      //If those compared bars need to be swapped we will color them green\n      await colorBars([left, right], colors.green, displayBars, speed);\n      //Here we are swapping the actual numbers in the array\n      swapNums(left, right, array);\n      //Here we are swapping bar heights on the screen\n      swapBarHeights(left, right, displayBars);\n      //Hee we are updating swaps count\n      updateSwaps_(++metricsInfo.swaps);\n    } else {\n      //If the value at array[left] is less than the pivot that means it's not what we are looking for so turn that bar white and move on\n      if (array[left] <= array[pivot]) {\n        updateChecks_(++metricsInfo.checks);\n        colorBars([left], 'white', displayBars);\n        left++;\n\n        if (left <= array.length - 1) {\n          await colorBars([left], colors.red, displayBars, speed);\n        }\n      }\n      //If the value at array[right] is greater than the pivot that means it's not what we are looking for so turn that bar white and move on\n      if (array[right] >= array[pivot]) {\n        updateChecks_(metricsInfo.checks);\n        colorBars([right], 'white', displayBars);\n        right--;\n        if (right >= 0) {\n          await colorBars([right], colors.red, displayBars, speed);\n        }\n      }\n    }\n  }\n\n  //After the two left and right pointer have eclipsed, the pivot number and right will swap positions\n\n  //Here we coloring them both green\n  colorBars([pivot, right], colors.green, displayBars, speed);\n  //Here we are swapping the numbers in the actual array\n  swapNums(pivot, right, array);\n  //Here we are swapping the bar heights on the screen\n  swapBarHeights(pivot, right, displayBars);\n  //Here I'm using the 'sorted' color to colore them(in reality only the just swapped pivot is in sorted order)\n  colorBars([right], colors.sorted, displayBars);\n  //Here i'm updating the swap count\n  updateSwaps_(++metricsInfo.swaps);\n\n  if (left <= array.length - 1) {\n    colorBars([left], 'white', displayBars);\n  }\n  //Here we are coloring the pivot position(which was just swapped) white\n  colorBars([pivot], 'white', displayBars);\n\n  //Here we are updating the recursive split count\n  updateRecursiveSplits_(++metricsInfo.splits);\n\n  //The next 2 lines are the recursion needed for quicksort to work. At every recursive split we pass in different parameters that act as new boundries to an array that quicksort will operate on\n  await quickSortHelper(start, right - 1, bars, metricsInfo);\n  await quickSortHelper(right + 1, stop, bars, metricsInfo);\n\n  //Here we are coloring all the bars that are done with their respective recursive splitting, sorted\n  for (let i = start; i <= stop + 1; i++) {\n    if (i < array.length - 1) {\n      colorBars([i], colors.sorted, displayBars);\n    }\n  }\n}\n","import { colorBars, colors } from '../utils';\nimport { displaySort } from '../utils';\n\n/**====================================================================================================================================\n * The array of numbers being sorted and the array of bars on the screen are NOT one in the same, but they do have a connection\n * When the array of numbers is generated, an array of heights is also generated\n * The array of heights is based off of the random numbers AND the current height of the container\n * This way we can assign the height of the bar as a percentage, so now the bar height will always be responsive to the container height\n * So no matter the current heights of the bars on the screen they always maintain their relationship to the numbers that generated them\n=======================================================================================================================================*/\n\nexport default async function mergeSort(bars, updates) {\n  if (bars.nums.length <= 1) return;\n\n  //The bars grabbed from the DOM are 'array-like' and not an actual array so we need to convert it to an array by calling Array.from()\n  bars.displayBars = Array.from(bars.displayBars);\n\n  //Destructuring the Redux states\n  const { nums: arr, initialHeights: heights } = bars;\n\n  //Here we are creating an object that holds all the metric info that we will pass down\n  const metricsInfo = { swaps: 0, checks: 0, splits: 0, updates };\n\n  const auxArr = arr.slice();\n  const auxHeights = heights.slice();\n\n  await mergeHelper(\n    0,\n    arr.length - 1,\n    arr,\n    auxArr,\n    heights,\n    auxHeights,\n    bars,\n    metricsInfo\n  );\n  updates.updateMainButton_('NEW');\n}\n/*================================================================================================================*/\n\n/*\nI decided to shorten the names for the prameters because there were to many and the formatting was looking un-readable\nmergeHelper(start, stop, main, auxArray, heights, auxHeights, bars, metricsInfo)\n*/\n\nasync function mergeHelper(st, sp, mn, ax, hts, axHts, bars, metInfo) {\n  const { updateRecursiveSplits_ } = metInfo.updates;\n  const { displayBars: dP, speed: spd } = bars;\n\n  //Base case\n  if (st === sp) return;\n  //Calculating the midPosition, this is what we will use to determine the left and right splits\n  const mP = Math.floor((st + sp) / 2);\n  //Updating the recursive split count\n  updateRecursiveSplits_(++metInfo.splits);\n\n  //It's important to know that in this version of merge sort the main and aux arrays will filp positions each time they are passed in to the recursive mergeHelper function\n\n  //Here we are recursivly splitting left\n  await mergeHelper(st, mP, ax, mn, axHts, hts, bars, metInfo);\n  //Here we are recursivly splitting right\n  await mergeHelper(mP + 1, sp, ax, mn, axHts, hts, bars, metInfo);\n\n  //Here we are merging our two halves. We pass in st(start), sp(stop) and mP(nidPoint) that way we can have access to the two halves\n  await merge(st, sp, mP, mn, ax, hts, axHts, bars, metInfo);\n\n  //Here we are cloring the bars\n  await displaySort(st, sp, dP, hts, spd, metInfo);\n}\n\n//mp === midPosition\nasync function merge(st, sp, mP, mn, ax, hts, axHts, bars, metInfo) {\n  const { updateChecks_ } = metInfo.updates;\n  const { speed, displayBars } = bars;\n\n  //'k' is the position in the main array\n  let k = st;\n  //'i' is the beginning of the first half of the aux array\n  let i = st;\n  //'j' is the beginning of the second half of the aux array\n  let j = mP + 1;\n\n  //mP(midPoint) is the end of the first half\n  //sp(stop) is the end of the second half\n\n  while (i <= mP && j <= sp) {\n    //Updating the checks count\n    updateChecks_(++metInfo.checks);\n    await colorBars([k], colors.red, displayBars, speed);\n    //Here we have two halves that we are comparing\n    //We will establish two pointers(i, j) for each respective half\n    //The lesser of the two values will be placed in the main array at the k position\n    if (ax[i] <= ax[j]) {\n      mn[k] = ax[i];\n      hts[k] = axHts[i];\n      i++;\n    } else {\n      mn[k] = ax[j];\n      hts[k] = axHts[j];\n      j++;\n    }\n    colorBars([k], colors.sorted, displayBars);\n    k++;\n  }\n\n  //This while loop will handle if position 'i' is still in bounds\n  while (i <= mP) {\n    updateChecks_(++metInfo.checks);\n    await colorBars([k], colors.red, displayBars, speed);\n    mn[k] = ax[i];\n    hts[k] = axHts[i];\n    colorBars([k], colors.sorted, displayBars, speed);\n    i++;\n    k++;\n  }\n\n  //This while loop will handle if position 'j' is still in bounds\n  while (j <= sp) {\n    updateChecks_(++metInfo.checks);\n    await colorBars([k], colors.red, displayBars, speed);\n    mn[k] = ax[j];\n    hts[k] = axHts[j];\n    colorBars([k], colors.sorted, displayBars, speed);\n    j++;\n    k++;\n  }\n}\n","import { colorBars, swapNums, swapBarHeights, colors } from '../utils';\n\n//=================================================================//\nexport default async function heapSort(bars, updates) {\n  let { nums: array, displayBars, speed } = bars;\n\n  //Here we are creating an object that holds all the metric info that we will pass down\n  const metricsInfo = { swaps: 0, checks: 0, updates };\n\n  //The bars grabbed from the DOM are 'array-like' and not an actual array so we need to convert it to an array by calling Array.from\n  displayBars = Array.from(displayBars);\n\n  //Here we are first contructing a max heap\n  //This will make sure that the current largest number in the unsorted partition of the array is at the front(0th index)\n  await constructHeap(array, displayBars, speed, metricsInfo);\n\n  //Once we construct the max heap we will swap the 0th element with the lat element in the unsorted partition of the array\n  for (let i = array.length - 1; i >= 0; i--) {\n    //Here position i starts at the very last element in the array and moves forward\n    //We always swap the 0th element with the 'i' position\n    swap(0, i, array, displayBars, metricsInfo);\n    //Here we are coloring the 'i' position that was just swapped. Not that element is in the sorted partition of the array\n    await colorBars([i], colors.sorted, displayBars, speed);\n    //After we swap the 0th element with the last element. We need to reconstruct the max heap, which requires sifting down that just swapped element at the 0th index\n    await siftDown(0, i - 1, array, displayBars, speed, metricsInfo);\n  }\n\n  colorBars([0], colors.sorted, displayBars, speed);\n\n  updates.updateMainButton_('NEW');\n}\n\n//=================================================================//\n\nasync function constructHeap(array, displayBars, speed, metricsInfo) {\n  //First we must calculate the location of the very first element with children, in other words, the first parent\n  const firstParentIndex = Math.floor((array.length - 2) / 2);\n  //Here we will use that first parent position to find it's children and move the first parent position to the left as we go, always calculating the position for that parents children\n  for (let i = firstParentIndex; i >= 0; i--) {\n    //The parents bar will be colored green\n    await colorBars([i], colors.green, displayBars, speed);\n    //The childrensposition is dependant on the parent position so we will pass the info down to 'siftDown' so the algorithm can decide what to do with the children and parent\n    await siftDown(i, array.length - 1, array, displayBars, speed, metricsInfo);\n    //After we process the children and parent we color the parent white\n    await colorBars([i], 'white', displayBars, speed);\n  }\n}\n\n//=================================================================//\n\nasync function siftDown(pos, lastIndex, array, bars, speed, metricsInfo) {\n  const { updateChecks_ } = metricsInfo.updates;\n\n  let leftChild = pos * 2 + 1;\n\n  while (leftChild <= lastIndex) {\n    await colorBars([leftChild], colors.red, bars, speed);\n    //Checking if the right child is available\n    const rightChild = pos * 2 + 2 <= lastIndex ? pos * 2 + 2 : -1;\n    //If it is color is red\n    if (rightChild !== -1)\n      await colorBars([rightChild], colors.red, bars, speed);\n\n    let indexToSwap;\n    //Checking which of the two is greater leftChild or rightChild and assigning that to indexToSwap\n    if (rightChild !== -1 && array[rightChild] > array[leftChild]) {\n      indexToSwap = rightChild;\n    } else {\n      indexToSwap = leftChild;\n    }\n    updateChecks_(++metricsInfo.checks);\n    //ONce we have decided which is larger turn the bars white\n    colorBars([leftChild], 'white', bars);\n    if (rightChild !== -1) colorBars([rightChild], 'white', bars, speed);\n\n    //Now we check if that child is great than our parent\n    if (array[indexToSwap] > array[pos]) {\n      //If it is we color them green\n      await colorBars([indexToSwap, pos], colors.green, bars, speed);\n      //Swap there positions\n      swap(pos, indexToSwap, array, bars, metricsInfo);\n\n      await colorBars([pos], colors.green, bars, speed);\n      colorBars([pos], 'white', bars, speed);\n\n      //Once we swap we move pos to be at the position of the child that just took it's place so we can now calculate the children of this new position\n      pos = indexToSwap;\n      leftChild = pos * 2 + 1;\n      colorBars([indexToSwap], 'white', bars);\n    } else {\n      await colorBars([pos, indexToSwap], 'white', bars, speed);\n      return;\n    }\n  }\n  colorBars([pos], 'white', bars);\n}\n\nasync function swap(positionOne, positionTwo, array, bars, metricsInfo) {\n  const { updateSwaps_ } = metricsInfo.updates;\n  swapNums(positionOne, positionTwo, array);\n  swapBarHeights(positionOne, positionTwo, bars);\n  updateSwaps_(++metricsInfo.swaps);\n}\n","import bubbleSort from './Algorithms/bubbleSort';\nimport selectionSort from './Algorithms/selectionSort';\nimport insertionSort from './Algorithms/insertionSort';\nimport quickSort from './Algorithms/quickSort';\nimport mergeSort from './Algorithms/mergeSort';\nimport heapSort from './Algorithms/heapSort';\n\n//This function is used to generate random numbers to be sorted by the algorithm and the heights that will be used in the display of the bars on screen\nexport function genArray(value, containerHeight) {\n  const nums = [];\n  const heightPercentages = [];\n  //Generating a random number\n  //Calculating a percentage based on that random number and the current container height\n  for (let i = 0; i < value; i++) {\n    const randomNum = genRandomNum(5, containerHeight);\n    const heightPercentage = Math.floor((randomNum / containerHeight) * 100);\n    nums.push(randomNum);\n    heightPercentages.push(heightPercentage);\n  }\n  return {\n    nums,\n    heightPercentages,\n  };\n}\n\nexport function genRandomNum(min, max) {\n  return Math.floor(Math.random() * (max - min + 1) + min);\n}\n\nexport function startSelectedAlgo(bars, buttonSelection, updates) {\n  switch (buttonSelection.algoName) {\n    case 'bubbleSort':\n      return bubbleSort(bars, updates);\n    case 'selectionSort':\n      return selectionSort(bars, updates);\n    case 'insertionSort':\n      return insertionSort(bars, updates);\n    case 'quickSort':\n      return quickSort(bars, updates);\n    case 'mergeSort':\n      return mergeSort(bars, updates);\n    case 'heapSort':\n      return heapSort(bars, updates);\n    default:\n      return;\n  }\n}\n\nexport async function swapBarHeights(barOnePos, barTwoPos, bars) {\n  const heightOne = bars[barOnePos].style.height;\n  const heightTwo = bars[barTwoPos].style.height;\n  bars[barOnePos].style.height = heightTwo;\n  bars[barTwoPos].style.height = heightOne;\n}\n\n//This function is used to pause the screen so we can see what is happeneing. It'a a way of animating\nexport async function pause(speed) {\n  await new Promise((resolve) =>\n    setTimeout(() => {\n      resolve();\n    }, speed)\n  );\n}\n\n//This function is used in mergeSort to swap the bars on the screen\nexport async function displaySort(start, stop, bars, heights, speed, metInfo) {\n  for (let i = start; i <= stop; i++) {\n    bars[i].style.height = `${heights[i]}%`;\n    metInfo.updates.updateSwaps_(++metInfo.swaps);\n    await pause(speed / 3);\n  }\n}\n\nexport async function colorBars(arrayOfPos, color, bars, speed = 0) {\n  for (let i = 0; i < arrayOfPos.length; i++) {\n    bars[arrayOfPos[i]].style.backgroundColor = color;\n  }\n  await pause(speed / 3);\n}\n\nexport function swapNums(posOne, posTwo, array) {\n  [array[posOne], array[posTwo]] = [array[posTwo], array[posOne]];\n}\n\n//Colors\nexport const colors = {\n  sorted: '#1c77c3',\n  green: '#a2dfba',\n  orange: '#ffdab7',\n  red: '#e67188',\n  blue: '#3481f5',\n};\n\nexport function getClassName(selectedButton, buttonName, mainButton) {\n  const className =\n    selectedButton === buttonName\n      ? 'algo-btn active-btn'\n      : mainButton !== 'START'\n      ? 'algo-btn disable-btn'\n      : 'algo-btn algo-green';\n  return className;\n}\n","import React from 'react';\nimport { connect } from 'react-redux';\nimport { updateAlgoButtonSelection } from '../store/buttonSelectionReducer';\nimport { updateBarCount, updateSpeed } from '../store/barsReducer';\nimport { getClassName } from '../utils';\n\n//================================================================================================================//\nfunction Controls({ bars, buttonSelection, updates }) {\n  //This handle click function uses event delegation to update which algorithm button has been clicked. The value passed is a string of the algorithm name\n  function handleButtonClick(e) {\n    if (e.target.value) {\n      updates.updateAlgoButtonSelection_(e.target.value);\n    }\n  }\n\n  //This handle change function takes the value of the slider and updates the barCount\n  function handleBarSlider(name) {\n    updates.updateBarCount_(name.target.value);\n  }\n\n  //This handle change function takes the value of the slider and updates the speed\n  function handleSpeed(name) {\n    updates.updateSpeed_(name.target.value);\n  }\n\n  //================================================================================================================//\n  const { mainButton, algoName } = buttonSelection;\n  const { barCount, speed } = bars;\n  //When an algorithm button is clicked the button will re-render with the color blue. This is based on the 'selectedButton' variable(which is a part of Redux state)\n  return (\n    <div className=\"controls-container\">\n      <div className=\"algo-buttons-container\">\n        <div className=\"algo-buttons\" onClick={(e) => handleButtonClick(e)}>\n          <button\n            value=\"bubbleSort\"\n            disabled={mainButton !== 'START' ? true : false}\n            className={getClassName(algoName, 'bubbleSort', mainButton)}\n          >\n            BUBBLE\n          </button>\n          <button\n            value=\"selectionSort\"\n            disabled={mainButton !== 'START' ? true : false}\n            className={getClassName(algoName, 'selectionSort', mainButton)}\n          >\n            SELECTION\n          </button>\n          <button\n            value=\"insertionSort\"\n            disabled={mainButton !== 'START' ? true : false}\n            className={getClassName(algoName, 'insertionSort', mainButton)}\n          >\n            INSERTION\n          </button>\n          <button\n            value=\"quickSort\"\n            disabled={mainButton !== 'START' ? true : false}\n            className={getClassName(algoName, 'quickSort', mainButton)}\n          >\n            QUICK\n          </button>\n          <button\n            value=\"mergeSort\"\n            disabled={mainButton !== 'START' ? true : false}\n            className={getClassName(algoName, 'mergeSort', mainButton)}\n          >\n            MERGE\n          </button>\n          <button\n            value=\"heapSort\"\n            disabled={mainButton !== 'START' ? true : false}\n            className={getClassName(algoName, 'heapSort', mainButton)}\n          >\n            HEAP\n          </button>\n        </div>\n      </div>\n      <div className=\"sliders-container\">\n        <div className=\"sliders bar-slider\">\n          <div>\n            <label>Bars</label>\n            <span>{barCount}</span>\n          </div>\n          <input\n            type=\"range\"\n            name=\"bars\"\n            disabled={mainButton !== 'START' ? true : false}\n            value={barCount}\n            min=\"5\"\n            max=\"400\"\n            step=\"5\"\n            className=\"slider\"\n            onChange={(name) => handleBarSlider(name)}\n          />\n        </div>\n        <div className=\"sliders\">\n          <div>\n            <label>Speed</label>\n            <span>{speed}</span>\n          </div>\n          <input\n            type=\"range\"\n            name=\"speed\"\n            disabled={mainButton !== 'START' ? true : false}\n            defaultValue=\"100\"\n            min=\"0\"\n            max=\"2000\"\n            step=\"5\"\n            className=\"slider speed-slider\"\n            onChange={(name) => handleSpeed(name)}\n          />\n        </div>\n      </div>\n    </div>\n  );\n}\n//================================================================================================================//\nconst mapStateToProps = ({ buttonSelection, bars }) => {\n  return {\n    bars,\n    buttonSelection,\n  };\n};\n\nconst mapDispatchToProps = (dispatch) => {\n  return {\n    updates: {\n      updateAlgoButtonSelection_: (button) => {\n        return dispatch(updateAlgoButtonSelection(button));\n      },\n      updateBarCount_: (value) => {\n        return dispatch(updateBarCount(value));\n      },\n      updateSpeed_: (value) => {\n        return dispatch(updateSpeed(value));\n      },\n    },\n  };\n};\n\nexport default connect(mapStateToProps, mapDispatchToProps)(Controls);\n","import React, { useEffect, useRef } from 'react';\nimport { connect } from 'react-redux';\nimport { updateBars } from '../store/barsReducer';\nimport { genArray } from '../utils';\n//Using the uuid libary for unique identifiers for react keys\nimport { v4 as uuidv4 } from 'uuid';\n\n//================================================================================================================//\nfunction Bars({ updateBars_, initialHeights, barCount }) {\n  const barsContainer = useRef(null);\n\n  useEffect(() => {\n    //We will use the container height to calculate the heights of the bars\n    const containerHeight = barsContainer.current.clientHeight;\n    const displayBars = barsContainer.current.childNodes;\n\n    //Here we are returning the actual numbers we are sorting(nums) and the initial heights(the initial heights will be a percentage of the container height, that way we can style the bar heights with a percentage which will allow for responsiveness)\n\n    //barCount comes from Redux state\n    const { nums, heightPercentages } = genArray(barCount, containerHeight);\n\n    //This is the only component that calls genArray(), so when we do call genArray() we need to make sure we update all the neccessary info about the bars so we will have access to the most up to date info about the bars in other components.\n\n    //A Redux action creator that updates the numbers we will be sorting(nums), the actual DOM bars being shown on screen(displayBars) and the display heights(heightPercentages)\n    updateBars_(nums, displayBars, heightPercentages);\n  }, [updateBars_, barCount]);\n  //================================================================================================================//\n  //initialHeights contains an arry of numbers that can be used to style the bar's height based on the height of the current container. Because we are styling the bar height with a percentage, if the height of the container changes, the heights of the bars will change proportionality.\n\n  //Because of this proportional change the bars will still have a connection to the numbers that are being sorted by the algorithm, the heights originate from these numbers\n\n  //The bars on the screen act as the visual representation of the numbers being sorted\n  return (\n    <div ref={barsContainer} className=\"bars-container\">\n      {initialHeights.map((height) => (\n        <div\n          className=\"bar\"\n          key={uuidv4()}\n          style={{ height: `${height}%` }}\n        ></div>\n      ))}\n    </div>\n  );\n}\n//================================================================================================================//\nconst mapStateToProps = ({ bars }) => {\n  return {\n    initialHeights: bars.initialHeights,\n    barCount: bars.barCount,\n  };\n};\n\nconst mapDispatchToProps = (dispatch) => {\n  return {\n    updateBars_: (nums, displayBars, initialHeights) => {\n      return dispatch(updateBars(nums, displayBars, initialHeights));\n    },\n  };\n};\n\nexport default connect(mapStateToProps, mapDispatchToProps)(Bars);\n","// Action Type\nconst UPDATE_SWAPS = 'UPDATE_SWAPS';\nconst UPDATE_CHECKS = 'UPDATE_CHECKS';\nconst UPDATE_RECURSIVE_SPLITS = 'UPDATE_RECURSIVE_SPLITS';\nconst RESET_METRICS = 'RESET_METRICS';\n\n// Action creators\nexport const updateSwaps = (value) => {\n  return {\n    type: UPDATE_SWAPS,\n    payload: {\n      swaps: value,\n    },\n  };\n};\n\n// Action creators\nexport const updateChecks = (value) => {\n  return {\n    type: UPDATE_CHECKS,\n    payload: {\n      checks: value,\n    },\n  };\n};\n\n// Action creators\nexport const updateRecursiveSplits = (value) => {\n  return {\n    type: UPDATE_RECURSIVE_SPLITS,\n    payload: {\n      splits: value,\n    },\n  };\n};\n\nexport const resetMetrics = () => {\n  return {\n    type: RESET_METRICS,\n    payload: {\n      swaps: 0,\n      checks: 0,\n      splits: 0,\n    },\n  };\n};\nconst initialState = {\n  swaps: 0,\n  checks: 0,\n  splits: 0,\n};\n\nconst barsReducer = (state = initialState, { type, payload }) => {\n  switch (type) {\n    case UPDATE_SWAPS:\n      return {\n        ...state,\n        swaps: payload.swaps,\n      };\n    case UPDATE_CHECKS:\n      return {\n        ...state,\n        checks: payload.checks,\n      };\n    case UPDATE_RECURSIVE_SPLITS:\n      return {\n        ...state,\n        splits: payload.splits,\n      };\n    case RESET_METRICS:\n      return {\n        ...state,\n        ...payload,\n      };\n    default:\n      return state;\n  }\n};\n\nexport default barsReducer;\n","import React from 'react';\nimport { connect } from 'react-redux';\nimport { startSelectedAlgo } from '../utils';\nimport { updateMainButton } from '../store/buttonSelectionReducer';\nimport { updateBarCount } from '../store/barsReducer';\nimport {\n  updateSwaps,\n  updateChecks,\n  updateRecursiveSplits,\n  resetMetrics,\n} from '../store/metricsReducer';\n\n//================================================================================================================//\nfunction StartButton({ bars, buttonSelection, updates }) {\n  const { mainButton } = buttonSelection;\n  //This function will change the main button from 'START' to 'NEW' to 'STOP'\n  function handleClick() {\n    switch (mainButton) {\n      case 'NEW':\n        //In order to for the bars to re-render I must pass it a prop of different value, so I'm passing it the barCount+1\n        updates.updateBarCount_(++bars.barCount);\n        updates.updateMainButton_('START');\n        updates.resetMetrics_();\n        break;\n      case 'START':\n        updates.updateMainButton_('STOP');\n        //Passing these props to a util function to start the chosen algorithm\n        startSelectedAlgo(bars, buttonSelection, updates);\n        break;\n      default:\n        window.location.reload();\n        break;\n    }\n  }\n\n  const btnName = buttonSelection.mainButton;\n  const btnType = `${buttonSelection.mainButton.toLowerCase()}-btn`;\n  //================================================================================================================//\n  return (\n    <div className={`${btnType}-container btn-container`}>\n      <button className={`btn ${btnType}`} onClick={() => handleClick()}>\n        {btnName}\n      </button>\n    </div>\n  );\n}\n//================================================================================================================//\nconst mapStateToProps = ({ bars, buttonSelection }) => {\n  return {\n    bars,\n    buttonSelection,\n  };\n};\n\nconst mapDispatchToProps = (dispatch) => {\n  return {\n    updates: {\n      updateMainButton_: (name) => {\n        return dispatch(updateMainButton(name));\n      },\n      updateBarCount_: (value) => {\n        return dispatch(updateBarCount(value));\n      },\n      updateSwaps_: (value) => {\n        return dispatch(updateSwaps(value));\n      },\n      updateChecks_: (value) => {\n        return dispatch(updateChecks(value));\n      },\n      updateRecursiveSplits_: (value) => {\n        return dispatch(updateRecursiveSplits(value));\n      },\n      resetMetrics_: () => {\n        return dispatch(resetMetrics());\n      },\n    },\n  };\n};\n\nexport default connect(mapStateToProps, mapDispatchToProps)(StartButton);\n","import React from 'react';\nimport { connect } from 'react-redux';\n\nfunction Metrics({ metrics, bars }) {\n  return (\n    <div className=\"metrics-container\">\n      <div className=\"metrics-sub-container\">\n        <div>\n          <label>Bars:</label>\n          <span>{bars.barCount}</span>\n        </div>\n        <div>\n          <label>Speed:</label>\n          <span>{bars.speed}</span>\n        </div>\n        <div>\n          <label>Swaps:</label>\n          <span>{metrics.swaps}</span>\n        </div>\n        <div>\n          <label>Checks:</label>\n          <span>{metrics.checks}</span>\n        </div>\n        <div>\n          <label>Recursive Splits:</label>\n          <span>{metrics.splits}</span>\n        </div>\n      </div>\n    </div>\n  );\n}\n\nconst mapStateToProps = ({ metrics, bars }) => {\n  return {\n    metrics,\n    bars,\n  };\n};\n\nexport default connect(mapStateToProps, null)(Metrics);\n","const descriptions = {\n  bubbleSort: {\n    title: 'Bubble Sort',\n    algoDescript:\n      'Bubble sort, sometimes referred to as sinking sort, is a simple sorting algorithm that repeatedly steps through the list, compares adjacent element and swaps them if they are in the wrong order.',\n    vizDescript:\n      'Be on the look out for when bars turn green. This means the current compared values are already in sorted order so the algorigthm will NOT make a swap and simply move on with the next value',\n    learningMode: 'Bar: 50 Speed: 30',\n    complexity: `Best: O(n) Time | O(1) Space\n    Average: O(n^2) Time | O(1) Space\n    Worst: O(n^2) Time | O(1) Space\n    `,\n  },\n  selectionSort: {\n    title: 'Selection Sort',\n    algoDescript:\n      'The selection sort algorithm sorts an array by repeatedly finding the minimum element (considering ascending order) from the unsorted partition and putting it at the beginning.',\n    vizDescript:\n      'Be on the look out for the red bar. This is the current smallest element that will be swapped with the anchor element(green bar)',\n    learningMode: 'Bar: 40 Speed: 40',\n    complexity: `Best: O(n^2) Time | O(1) Space\n    Average: O(n^2) Time | O(1) Space\n    Worst: O(n^2) Time | O(1) Space\n    `,\n  },\n  insertionSort: {\n    title: 'Insertion Sort',\n    algoDescript:\n      \"Insertion sort, is a simple sorting algorithm that splits the input into two parts, sorted and unsorted. It will select the current unsorted element and find it's place in the sorted sub-array\",\n    vizDescript:\n      \"Be on the look out for the red bar travling back. This is the algorithm looking for it's correct place in the already sorted partition. When it finds it's position the bar will turn green\",\n    learningMode: 'Bar: 30 Speed: 50',\n    complexity: `Best: O(n) Time | O(1) Space\n    Average: O(n^2) Time | O(1) Space\n    Worst: O(n^2) Time | O(1) Space\n    `,\n  },\n  quickSort: {\n    title: 'Quick Sort',\n    algoDescript: `Quick sort is a pivot sorting recursive algorithm. It compares values based on an established pivot value and sections the array into elements less than the pivot and elements greater than the pivot. \n      \n      It recursively continues this work for every partition(less than partition, greater than partition) of the input array`,\n    vizDescript: `Be on the look out for the green bar(pivot) and two red bars moving closer and closer to each other. The green bar is the pivot, and the two red bars are the left and right pointers respectively. \n    \n    The left pointer is looking for values greater than the pivot value, the right pointer is looking for values less than the pivot. If they don't have what they need they move on, but if they BOTH have what they need they swap values(bars).\n    \n    Once the left and right pointers eclipse each other the pivot will take it's place at that intersection point and the result will be all values to the left are smaller than the pivot and all values to the right are bigger than the pivot.`,\n    learningMode: 'Bar: 20 Speed: 60',\n    complexity: `Best: O(nlog(n)) Time | O(log(n)) Space\n    Average: O(nlog(n)) Time | O(log(n)) Space\n    Worst: O(n^2) Time | O(log(n)) Space\n    `,\n  },\n  mergeSort: {\n    title: 'Merge Sort',\n    algoDescript: `Merge sort repeatedly breaks down a list into 'n' sublists until each sublist consists of a single element and merging those sublists in a manner that results into a sorted list.`,\n    vizDescript: `Merge sort will break down an array into single elements by splitting in half at each iteration(left half, right half). \n      \n    When it reaches it's base case(single element) it will return. Remember that a single element is by definition, sorted. At each return it will have a left sorted sub-array and a right sorted sub-array. \n      \n    It will merge these two sorted sub-arrays, producing a merged sorted sub-array for that recursive level, then return it. \n      \n    That returned sub-array is now one of the sorted halves that will be merged with the other sorted half from the opposite side of the recursive tree\n    \n    Be on the look out for the 'spiked' partitions. These are the sorted sub-arrays that will be merged into a larger sorted sub-array. Notice how the 'spiked' partitions are merged in two's(left half, right half)`,\n    learningMode: 'Bar: 10 Speed: 70',\n    complexity: `Best: O(nlog(n)) Time | O(nlog(n)) Space\n    Average: O(nlog(n)) Time | O(nlog(n)) Space\n    Worst: O(nlog(n)) Time | O(nlog(n)) Space\n    `,\n  },\n  heapSort: {\n    title: 'Heap Sort',\n    algoDescript: `Heapsort is a comparison-based sorting algorithm. Heapsort can be thought of as an improved selection sort: like selection sort, heapsort divides its input into a sorted and an unsorted region, and it iteratively shrinks the unsorted region by extracting the largest element from it and inserting it into the sorted region. \n      \n    Unlike selection sort, heapsort does not waste time with a linear-time scan of the unsorted region; rather, heap sort maintains the unsorted region in a heap data structure to more quickly find the largest element in each step.`,\n    vizDescript: `Heap sort will begin by building a MAX HEAP. This will guarantee that the largest number in the unsorted partition of the array is at the beginning of the array. \n    \n    After the max heap has been built it will swap the largest value, which is now located at the 0th index with the value at the last index. Then it will rebuild the max heap in the unsorted partition and once again grab the largest element at the 0th index and swap it with the last index in the unsorted partition.\n      \n    A max heap is built by conceptually viewing the array as a heap data structure, which is in essance a binary tree where every node is greater than or equal to it's two children nodes.\n    \n    Be on the look out for the green and red bars. The green bar is the 'parent' and the red bars are the 'children' of the parent. The 'parent' node will ask it self, 'Which one of my children is of greater value than I ?'. If a child of greater value is found the parent will swap positions with it.\n    \n    To calculate parent-child positional relationship use the following formula...\n    \n    leftChild = parentIndex * 2 + 1\n    rightChild = parentIndex * 2 + 2`,\n    learningMode: 'Bar: 0 Speed: 80',\n    complexity: `Best: O(nlog(n)) Time | O(1) Space\n    Average: O(nlog(n)) Time | O(1) Space\n    Worst: O(nlog(n)) Time | O(1) Space\n    `,\n  },\n};\n\nexport default descriptions;\n","import React, { useEffect, useState } from 'react';\nimport { connect } from 'react-redux';\nimport descriptions from '../descriptions';\nimport SimpleBar from 'simplebar-react';\nimport 'simplebar/dist/simplebar.min.css';\n\nfunction AlgoDescription({ selectedButton }) {\n  const [descript, setDescript] = useState(descriptions.bubbleSort);\n\n  //The description that appears on the screen is chosen by the the function getSelectedDescription\n  //This function will take in the selectedButton which is a prop from the redux state and use that to pick a description\n  useEffect(() => {\n    setDescript(getSelectedDescription(selectedButton, descriptions));\n  }, [selectedButton]);\n\n  return (\n    <div className=\"algo-description-container\">\n      <SimpleBar className=\"descrip-scroll\">\n        <div className=\"descrip-sub-container\">\n          <h1 className=\"descrip-title\">{descript.title}</h1>\n          <div className=\"descrip-body\">\n            <div className=\"algo-description\">\n              <h3>Algorithim Description</h3>\n              <p>{descript.algoDescript}</p>\n            </div>\n            <div className=\"viz-description\">\n              <h3>Visualization Description</h3>\n              <p>{descript.vizDescript}</p>\n            </div>\n            <div className=\"complexity\">\n              <h4>Complexity</h4>\n              <p>{descript.complexity}</p>\n            </div>\n          </div>\n        </div>\n      </SimpleBar>\n    </div>\n  );\n}\n\nfunction getSelectedDescription(selectedButton, descriptions) {\n  return descriptions[selectedButton];\n}\n\nconst mapStateToProps = ({ buttonSelection }) => {\n  return {\n    selectedButton: buttonSelection.algoName,\n  };\n};\n\nexport default connect(mapStateToProps, null)(AlgoDescription);\n","import Controls from './Controls';\nimport Bars from './Bars';\nimport StartButton from './StartButton';\nimport Metrics from './Metrics';\nimport AlgoDescription from './AlgoDescription';\n\nexport default function SortingPage() {\n  return (\n    <div className=\"page\">\n      <div className=\"page-top\">\n        <div className=\"page-top-left\">\n          <AlgoDescription />\n        </div>\n        <div className=\"page-top-right\">\n          <Bars />\n        </div>\n      </div>\n      <div className=\"page-bottom\">\n        <div className=\"page-bottom-left\">\n          <Controls />\n        </div>\n        <div className=\"page-bottom-mid\">\n          <StartButton />\n        </div>\n        <div className=\"page-bottom-right\">\n          <Metrics />\n        </div>\n      </div>\n    </div>\n  );\n}\n","import React from 'react';\n\nexport default function Nav() {\n  return (\n    <nav className=\"nav\">\n      <div className=\"title\">SORTING VISUALIZER</div>\n    </nav>\n  );\n}\n","import SortingPage from './Components/SortingPage';\nimport Nav from './Components/Nav';\n\nfunction App() {\n  return (\n    <>\n      <Nav />\n      <SortingPage />\n    </>\n  );\n}\n\nexport default App;\n","import { combineReducers } from 'redux';\nimport { createStore } from 'redux';\nimport barsReducer from './barsReducer';\nimport buttonSelectionReducer from './buttonSelectionReducer';\nimport metricsReducer from './metricsReducer';\n\nconst rootReducer = combineReducers({\n  bars: barsReducer,\n  buttonSelection: buttonSelectionReducer,\n  metrics: metricsReducer,\n});\nconst store = createStore(rootReducer);\n\nexport default store;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport { Provider } from 'react-redux';\nimport store from './store/rootReducer';\n\nReactDOM.render(\n  <Provider store={store}>\n    <React.StrictMode>\n      <App />\n    </React.StrictMode>\n  </Provider>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}